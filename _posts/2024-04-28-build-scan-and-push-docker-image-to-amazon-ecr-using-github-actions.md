---
title: "Build, Scan, and Push Docker image to Amazon ECR using GitHub Actions"
date: 2024-04-28 13:34:22 +0000
categories: []
tags: []
---

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">This blog post is the second part of an umbrella series in which I demonstrate how to create and deploy an Amazon Elastic Container Service (ECS) service using Terraform and GitHub Actions. In the first part, I covered<a href="https://skundunotes.com/2024/04/10/create-infrastructure-to-host-an-amazon-ecs-service-using-terraform/" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff"> creating all the required AWS cloud services to host the ECS service</span></span></span></a>. In this second part, I'll focus on creating a Docker image from a Dockerfile in GitHub Actions and pushing that image into an Amazon Elastic Container Registry (ECR) repository.</span></span></span>
<!--more-->
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">By combining the power of Amazon ECR and GitHub Actions, we can streamline the process of building and deploying your containerized applications, ensuring consistent and reliable deployment across different environments.</span></span></span>

<strong><span style="font-size: 20px"><span style="font-family: calibri"><span style="color: #000000">Prerequisites</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Before we dive into the details, ensure that you have the following prerequisites in place:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">- An AWS account and the necessary permissions to create and access Amazon ECR repositories.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">- A GitHub code repository containing your application and a Dockerfile.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">- Basic understanding of Docker, AWS services, and GitHub Actions workflows.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">At a high level, there are <strong>three steps</strong> to pushing a Docker image to an Amazon ECR repository using GitHub Actions. These are:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>1.</strong> Create an Amazon ECR Repository</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>2.</strong> Configure AWS Credentials for GitHub Actions and</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>3.</strong> Create a GitHub Actions Workflow</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I will now explain these steps in detail.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">1. Create an Amazon ECR Repository</span></span></span></strong>
<img class="alignnone size-full wp-image-3708" src="https://skundunotes.com/wp-content/uploads/2024/04/91-image-9.png" alt="91-image-9" width="824" height="284" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Other AWS services, along with the Amazon ECR repository, would be required. I covered how to provision these resources in detail in my article on <a href="https://skundunotes.com/2024/04/10/create-infrastructure-to-host-an-amazon-ecs-service-using-terraform/" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">creating AWS infrastructure to host an Amazon ECS service</span></span></span></a>.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">2 . Configure AWS Credentials for GitHub Actions</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">To authenticate with AWS from your GitHub Actions workflow, you'll need to configure AWS credentials. Follow the steps outlined in [<a href="https://skundunotes.com/2023/02/28/securely-integrate-aws-credentials-with-github-actions-using-openid-connect/" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">this detailed guide</span></span></span></a>] to set up the required AWS credentials and store them as a GitHub repository secret.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">3. Create a GitHub Actions Workflow</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The entire logic of creating and pushing a Docker image is managed in the GitHub Actions YML file. </span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><img class="alignnone  wp-image-3707" src="https://skundunotes.com/wp-content/uploads/2024/04/91-image-8.png" alt="91-image-8" width="311" height="301" /></span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">This workflow file (<code style="background-color: #dcdcdc;font-size: 15px;color: #000000">app-ci-cd.yml</code>) is under the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">.github/workflows/</code> directory and contains the steps to build and push the Docker image to Amazon ECR. You can access this from my <a href="https://github.com/kunduso/add-aws-ecr-ecs-fargate/tree/create-ecs-service/.github/workflows" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">GitHub repository: add-aws-ecr-ecs-fargate</span></span></span></a>. </span></span></span><em><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #ff0000">Please note that the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">branch name = create-ecs-service</code>.</span></span></span></em>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I also set a couple of environment variables in the YML file. These are the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">AWS Region</code> where the Amazon ECR is located and the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">name</code> of the private repository. I then used several actions from the marketplace to complete the tasks. Let me walk through the YML file and explain it step by step.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">(a) Create a unique image tag for the Docker Image:</span></span></span></strong>
<img class="alignnone size-full wp-image-3699" src="https://skundunotes.com/wp-content/uploads/2024/04/91-image-2.png" alt="91-image-2" width="841" height="130" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I set <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">tag_immutability</code> to <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">enabled</code> in the Amazon ECR repository and hence had to ensure that the Docker image tags were unique for each push. I could have used the Git Commit SHA, but I preferred one that gave me better context, like the one I used. This tag contains the pipeline trigger date, the GitHub run number, and the run attempt, ensuring that even if the same pipeline run is re-triggered, it will create a new image tag.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">(b) Authenticate to AWS Cloud:</span></span></span></strong>
<img class="alignnone size-full wp-image-3700" src="https://skundunotes.com/wp-content/uploads/2024/04/91-image-3.png" alt="91-image-3" width="943" height="216" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">This step uses the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">aws-actions/configure-aws-credentials</code> action to configure the AWS credentials required for authenticating with AWS services. The action retrieves the IAM_ROLE from the GitHub secrets I set up earlier.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">(c) Authenticate to Amazon ECR:</span></span></span></strong>
<img class="alignnone size-full wp-image-3701" src="https://skundunotes.com/wp-content/uploads/2024/04/91-image-4.png" alt="91-image-4" width="857" height="183" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">This step uses the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">aws-actions/amazon-ecr-login</code> action to authenticate with Amazon ECR. This action retrieves an authentication token and configures Docker to use it to push and pull images from Amazon ECR.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The action is from the [<a href="https://github.com/marketplace/actions/amazon-ecr-login-action-for-github-actions" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">AWS Action for Amazon ECR</span></span></span></a>] repository on GitHub. It provides a convenient way to log in to Amazon ECR without manually retrieving and storing the authentication token. The action supports multiple use cases, such as cross-account authentication and integration with AWS CodeBuild.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">(d) Build and tag Docker image to Amazon ECR:</span></span></span></strong>
<img class="alignnone size-full wp-image-3702" src="https://skundunotes.com/wp-content/uploads/2024/04/91-image-5.png" alt="91-image-5" width="659" height="144" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">In this step, we build the Docker image using the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">docker build</code> command, tag it with the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">TAG_NAME</code> environment variable created earlier. Since I had set the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">working-directory: ./app</code> earlier in the YML file, the build step found the Dockerfile in that location.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">(e) Scan Docker image for vulnerabilities:</span></span></span></strong>
<img class="alignnone size-full wp-image-3703" src="https://skundunotes.com/wp-content/uploads/2024/04/91-image-6.png" alt="91-image-6" width="718" height="305" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I used Aqua Security's Trivy vulnerability scanner to scan the Docker image. This step identifies and addresses potential vulnerabilities in your Docker images before pushing them to Amazon ECR. The next step is to upload the report to the repository’s security findings, which are stored under the Security tab.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">(f) Push the Docker image to the Amazon ECR repository:</span></span></span></strong>
<img class="alignnone size-full wp-image-3704" src="https://skundunotes.com/wp-content/uploads/2024/04/91-image-7.png" alt="91-image-7" width="673" height="191" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The last step in the workflow is to push the Docker image to the Amazon ECR repository using the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">docker push</code> command. The <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">REGISTRY</code>, <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">REPOSITORY</code> and <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">IMAGE_TAG</code> environment variables are used to construct the full image URL. I also set a condition to the step since I did not want it to run in case it is triggered due to a pull request.</span></span></span>

<strong><span style="font-size: 20px"><span style="font-family: calibri"><span style="color: #000000">Best Practices</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I implemented a few best practices, such as (1) <span style="text-decoration: underline">separate build and push steps</span> for better control and flexibility, (2) <span style="text-decoration: underline">scanning</span> the Docker image for vulnerabilities, and (3) <span style="text-decoration: underline">storing the secrets</span> securely using GitHub Secrets. However, there are some more best practices to consider when pushing Docker images to Amazon ECR using GitHub Actions:</span></span></span>
<ul>
 	<li><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Use Caching for Faster Builds:</strong> GitHub Actions provides caching mechanisms that can significantly speed up your Docker build process by caching layers between builds.</span></span></span></li>
 	<li><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Use Semantic Versioning:</strong> Implement a versioning strategy for your Docker images using semantic versioning principles. This will make managing and tracking changes over time more convenient.</span></span></span></li>
</ul>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">And that brings us to the end of this note. I hope you enjoyed learning how to automate the process of building and pushing Docker images to Amazon ECR using GitHub Actions. By leveraging the power of these two services, you can streamline your application deployment process, ensuring consistent and reliable deployments across different environments.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">If you want, <span style="text-decoration: underline">fork out this repository</span> and give it a try. Commit and push your changes to the GitHub repository. That should trigger the GitHub Actions workflow you created, which will build your Docker image and push it to the specified Amazon ECR repository. You can monitor the progress of the workflow under the "Actions" tab of your GitHub repository. If the workflow completes successfully, your Docker image will be available in the Amazon ECR repository. Ensure that you complete the prerequisites before you trigger the workflow. <span style="text-decoration: underline">Let me know if you have any questions.</span></span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">As a next step, I will demonstrate how we can explore integrating this workflow with other AWS services, such as Amazon Elastic Container Service (ECS), to deploy the containerized applications seamlessly.</span></span></span>
