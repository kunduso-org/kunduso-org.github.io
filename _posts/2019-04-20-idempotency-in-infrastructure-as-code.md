---
title: "Idempotency in Infrastructure as Code"
date: 2019-04-20 02:22:49 +0000
categories: []
tags: []
---

<!-- wp:html --><p><em><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">(this thought process derives heavily from my experience as a scm, build and release engineer working on automation, scripting and trying to make my job exciting. Feel free to disagree)</span></span></span></em></p><p><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">In the earlier days (2000's maybe?) most of the tasks around build and release involved manual steps in the follow sequence:</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Step 1: development check-in code</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Step 2: build solution</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Step 3: create deployment package</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Step 4: stop services (in case of windows -iis/windows services)</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Step 5: copy package to deployment server</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Step 6: start services</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Step 7: start verification (testing)</span></span></span></p><p><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Then the continuous integration wave automated Step 1 through 3 and continuous deployment automated step 4 through 6. After automating this, I think the next challenge was around automating infrastructure that supported the application.</span></span></span><!--more--></p><p><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">While tacking infrastructure automation, the first round was around -do something.</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">But this approach had a limitation, in a way that it was not repeatable. Say for example the infra automation job was to copy a file into a shared location. The automation program would work the first time, but if we were to execute the program the second time (when the file already exists) the operation would fail. This could be true for any automation task -create an artifact, modify state of an artifact or delete an artifact.</span></span></span></p><p><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">This limitation introduced a wrapper around the automation program and that is to -check if the desired state already exists and modify only if it warrants a change. Simply put: check before you proceed. This is idempotency.</span></span></span></p><p style="padding-left:150px;"><strong><span style="font-size:large;"><span style="font-family:calibri;"><span style="color:#808000;">Do no change if system is already in desired state.</span></span></span></strong></p><p><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">And, as an organization moves towards building their infrastructure as code, adhering to idempotency is a necessary condition for the code, else the turnaround cycle will be unnecessarily long.</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">For example imagine a IaC module that is not idempotent. This would imply that all processes/steps have to start from the very beginning; there is no support for those systems that are partially configured. Now imagine doing this when you have more than a few dozen servers to deal with. There would be a lot of wastage in the approach. Moreover, a script or program that is not idempotent is:</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">-not scalable: extending (or adding) functionality is challenging</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">-not repeatable: without bringing system back to initial state</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">-limiting: the purpose of automation (increased productivity) is defeated</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">-longer feedback loop: in a way that any subsequent change that is introduced would imply that all previously coded automation must execute before newer functionality can be implemented</span></span></span></p><p><img class="alignnone size-full wp-image-80" src="https://skundunotes.com/wp-content/uploads/2019/10/idempotency-and-iac-image1.jpg" alt="Idempotency and IaC -Image1" width="752" height="420" /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">On the other hand IaC module that is idempotent has all the opposite traits.<br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">-scalable: build on existing state</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">-repeatable: do nothing is artifact exists in desired state</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">-not limiting: adheres with the objective of automation; increased productivity</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">-shorter feedback loop: since resources would not be spent on altering artifact state</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">-and also extremely reliable since it gets executed multiple times going across resources that are in various states of configuration.</span></span></span></span></span></span><br /><img class="alignnone size-full wp-image-81" src="https://skundunotes.com/wp-content/uploads/2019/10/idempotency-and-iac-image2.jpg" alt="Idempotency and IaC -Image2" width="716" height="404" /><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Now the question that arises is -how do you build idempotent programs/scripts? And the solution is quite simple. There is only one condition block needed</span></span></span></p><p><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">-check if artifact exists in desired state:</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">If yes: do nothing</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">If no: do something</span></span></span><br /><img class="  wp-image-82 alignnone" src="https://skundunotes.com/wp-content/uploads/2019/10/idempotency-and-iac-image3.jpg" alt="Idempotency and IaC -Image3" width="513" height="491" /><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">An alternate approach can be:</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">-check if artifact exists in desire state:</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">If yes: bring artifact back to initial state (delete/revert it) and then do something</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">If no: do something</span></span></span></p><p><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Although, both approaches have their merits and demerits my preference is to use the former until that becomes a challenge (complex difficult to check logic) in which case using later would make sense.</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Another feature (apart from idempotency) that I think is necessary in any IaC module is ease of understanding so that if someone else has to take over and maintain what you created, there is very less learning curve. It is important to note that an underlying objective of creating IaC modules is to make a system process dependent and not person dependent. At the same time, if someone has to modify the program (and if that someone is not you), you want them to be able to do that in as little time as possible. Remember, productivity is also an objective we are trying to achieve here. You do not want yourself or your IaC module to be a bottleneck. And in that regard, creating appropriate documentation (detailed comment in sripts/wiki) might be useful.</span></span></span><br /><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">The easier your IaC modules are to understand and implement, the wider would be their acceptance and the longer will your legacy life -if that makes you feel good ðŸ˜‰</span></span></span></p><p><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Oh, and do not forget to add your code into a source code repo.</span></span></span></p><!-- /wp:html -->
