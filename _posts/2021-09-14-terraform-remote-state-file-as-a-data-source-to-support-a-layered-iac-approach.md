---
title: "Terraform remote state file as a data source to support a layered IAC approach"
date: 2021-09-14 11:03:45 +0000
categories: []
tags: []
---

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">A few months back, I came across an interesting concept of deploying infrastructure in a layered fashion, and I wish I had the URL saved to refer to it again. Nevertheless, the gist of the idea was that you could build an application product environment by deploying layer after layer of infrastructure. A layer of infrastructure sits on another layer such that the upper layer depends on the lower layer. For example, the first layer could be - <em>create-network-infrastructure</em>. The second layer could be - <em>create-DNS</em>, which is followed by the <em>create-databases</em> layer and <em>create-application-host</em> layer. And finally, the <em>application</em>, as the last layer. Of course, there can be many smaller layers in between too, but you get the concept.</span></span></span>
<!--more-->
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Previously I worked on a similar use case when I created a vpc-peering between two Amazon VPCs that belonged to separate accounts. One of the pre-requisites was that both the Amazon VPCs must exist. So, following the layer conversation from above, the - <em>create-vpc-peering</em> layer sits on top of the <em>create-network-infrastructure</em> layer.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">In the previous Terraform configuration project, to create the peering connection, I must provide the VPC IDs of both the Amazon VPCs to the vpc-peering Terraform configuration project. You can read more about it <span style="text-decoration: underline"><a href="https://skundunotes.com/2021/08/24/vpc-peering-using-terraform-across-separate-aws-accounts/" target="_blank" rel="noopener">here</a></span>. However, that option was not scaleable. If I stood up an application product environment from the ground up, the network-infrastructure IDs (VPC ID, etc.) would be different every time. That would imply that I must update the vpc-peering project with new IDs when I require a peering relationship. That does not align entirely with an important IaC capability: <strong>re-usable</strong>. The vpc-peering configuration project code wouldn't be re-usable if I provided the vpc IDs each time they changed. The good news is that there is an alternate way to provision cloud resources without sharing the IDs in the code, making it more re-usable. And that is, by using a Terraform state file as a data source. There are pros and cons to that approach and particular situations I cannot use, and I will discuss them in this note.</span></span></span>

<em><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Note: Yes, instead of sharing the VPC ID in the code as I had in the previous Terraform configuration project, I could have passed it as a command-line variable, and that way, I would not have to store that in a repository. Although it would have made the configuration re-usable, someone still had to fetch the correct IDs and provide them to the Terraform configuration.</span></span></span></em>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I'm assuming that you, the reader, are aware of the data source resource type. You can read more <span style="text-decoration: underline"><a href="https://www.terraform.io/docs/language/data-sources/index.html" target="_blank" rel="noopener">here</a></span>. Using <code>terraform_remote_state</code> as a data source is quite similar to that. Using that resource block, I can access only those resources that have been exposed in the remote state via the output block. Say, e.g., I am using an existing terraform configuration as a remote state, and that configuration does not have any outputs. In that case, even if I have access to the remote state file, I won't have to access any information inside the state file. You can read about remote state data sources <span style="text-decoration: underline"><a href="https://www.terraform.io/docs/language/state/remote-state-data.html" target="_blank" rel="noopener">here</a></span>.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Let me now walk you through the use case so that you can follow along.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Situation:</strong> Two separate Terraform configuration projects created separate Amazon VPCs, a couple of public and private subnets, and route tables, among other resources. Also, both these projects have a remote backend to store the <code>terraform.tfstate</code> files. There are no overlapping CIDR blocks between the two VPCs.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Task:</strong> The requirement was to create a peering connection between these two Amazon VPCs such that resources in the public subnets of these two VPCs can communicate with each other.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Approach: </strong>Having worked on a similar project in the past, I had a fair idea of creating a peering connection.
Creating a successful peering connection involves four steps - (i) initiate a peering request from the peering owner Amazon VPC, (ii) accept the peering request from the accepting Amazon VPC, (iii) update the peering owner's route table with CIDR blocks from the accepting VPC/subnet, and (iv) update the accepting VPC route table with CIDR blocks from the peering owner VPC/subnet.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">It is also necessary to mention the user credential that I used in this project. The user in the VPC-peering Terraform project needs access to carry out the above four operations in separate AWS accounts. Moreover, since the user also fetches the information (VPC ID, subnet CIDR block, Route table ID, and Account ID) from two separate Terraform remote state files, it requires access to read those state files. I prefer using a restrictive access policy when working with cloud resources. In that regard, I used the assume-role functionality to manage the resources in the two Amazon VPCS that belonged to two separate accounts. You can read about how to create a trusted-trusting relationship across accounts <span style="text-decoration: underline"><a href="https://skundunotes.com/2021/06/05/creating-iam-assume-role-relationship-between-two-aws-accounts/" target="_blank" rel="noopener">here</a></span>. I achieved this by attaching the following policies to the user: (i) policy to read the two terraform state files(<code>s3: GetObject</code> on the state file), and (ii) policy to assume a role in both the accounts to create the peering relationship. I also included the policy file in my Github repository alongside the Terraform configuration.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Also, since I'm using the <code>terraform_remote_state</code> data resource, the existing resources (VPCs, subnets, route-tables) need to be:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">1. Configured using Terraform.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">2. The state file must be remote and accessible.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">3. The state file must expose required outputs, namely, VPC ID, account ID, route table ID, and subnet CIDR block.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Here is an example of the output block from the VPC Terraform project whose outputs are accessed in the current VPC-peering Terraform project.</span></span></span>
<img class="alignnone size-full wp-image-1480" src="https://skundunotes.com/wp-content/uploads/2021/09/50.image-2.png" alt="50.Image-2" width="493" height="255" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The above two conditions, (i) user having required permission, and (ii) state of existing infrastructure and the state files, are pre-requisites for this approach to work successfully.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Before I get into the steps to create a VPC-peering, I want to discuss how the existing state files are accessed. The link to the GitHub repository is available at: <span style="text-decoration: underline"><a href="https://github.com/kunduso/aws-vpc-peering-using-terraform" target="_blank" rel="noopener">aws-vpc-peering-using-terraform</a></span>.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I am using two VPCs to create the peering, and one of them is an owner, and the other is the accepter. Hence, while accessing the state files, I named them accordingly. The below image has details.</span></span></span>
<img class="alignnone size-full wp-image-1481" src="https://skundunotes.com/wp-content/uploads/2021/09/50.image-3.png" alt="50.Image-3" width="441" height="402" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Using the <code>data "terraform_remote_state"</code> resource type, I can access the state file of the two existing Amazon VPCs. Note that I have to provide the backend and the supporting configuration to access the state file.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">After accessing, the state files, for convenience, I added a locals block which made it easier to access the value of the output of the state files.</span></span></span>
<img class="alignnone size-full wp-image-1482" src="https://skundunotes.com/wp-content/uploads/2021/09/50.image-4.png" alt="50.Image-4" width="798" height="351" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Let me now walk through the steps involved in creating a peering relationship.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Step 1:</strong> Initiate a peering request from the peering owner VPC</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I used resource <code>aws_vpc_peering_connection</code> to initiate a peering connection. This information is available at <span style="text-decoration: underline"><code><a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/vpc_peering_connection" target="_blank" rel="noopener">vpc_peering_connection</a></code></span>.</span></span></span>
<img class="alignnone size-full wp-image-1483" src="https://skundunotes.com/wp-content/uploads/2021/09/50.image-5.png" alt="50.Image-5" width="567" height="192" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Step 2:</strong> Accept the peering request from the accepting VPC</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I used the resource <code>aws_vpc_peering_connection_accepter</code> to accept the peering connection. This information is available at <a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/vpc_peering_connection_accepter" target="_blank" rel="noopener"><code><span style="text-decoration: underline">vpc_peering_connection_accepter</span></code></a>.</span></span></span>
<img class="alignnone size-full wp-image-1484" src="https://skundunotes.com/wp-content/uploads/2021/09/50.image-6.png" alt="50.Image-6" width="530" height="155" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Step 3 and 4: </strong>Update the two route tables with CIDR blocks from the other VPC/subnet</span></span></span>
<img class="alignnone size-full wp-image-1485" src="https://skundunotes.com/wp-content/uploads/2021/09/50.image-7.png" alt="50.Image-7" width="676" height="269" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Finally, I used the <code>aws_route</code> resource type to update the route tables in the two VPCs. This information is available at <span style="text-decoration: underline"><a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/route" target="_blank" rel="noopener"><code>aws_route</code></a></span>. Also, note that I had to add a provider to each resource type since these are created in separate AWS accounts. If the peering is between two VPCs in the same account, the provider configuration is not required if the user has permission to manage both VPCs.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Pros and Cons to this approach:</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">A significant benefit of this approach is that it makes the configuration completely re-usable every time the infrastructure stack has to be re-created. Simultaneously, I had to be careful about what information was being exposed via the output block and provide only that much information, as is required.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Where can this approach not work:</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">This approach is based on the assumption that the lower-level layers are created using Terraform. If Terraform is not used, then there is no <code>terraform.tfstate</code> file. And if there is no such file, there is nothing for the <code>data "terraform_remote_state"</code> resource type to read off of. In such cases, using the data resource type would be a good idea.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I hope you enjoyed reading this note and found it helpful. Let me know if there are any clarifications necessary.</span></span></span>
