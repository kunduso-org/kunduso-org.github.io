---
title: "YAML based Azure Pipeline approach for CI/CD of Terraform workspace"
date: 2021-07-18 11:10:56 +0000
categories: []
tags: []
---

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">This note is a short addition to the last post -<a href="https://skundunotes.com/2021/07/10/ci-cd-of-terraform-workspace-with-yaml-based-azure-pipelines/" target="_blank" rel="noopener">CI/CD of Terraform workspace with YAML-based Azure Pipelines</a>. At the end of that article, I mentioned a few alternate routes regarding YAML-based Azure Pipelines, which I will be covering here.</span></span></span>
<!--more-->
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">So that we are on the same page, I broke down the build pipeline into four stages: Validate, Dev, Test, and Prod. Under <code>stage: validate</code>, I added a job that included <code>terraform init</code> and <code>terraform validate</code> for all workspaces. Then under <code>stage: Dev</code>, I added three jobs - plan, approve, and apply. Finally, I followed the same approach for <code>stage: Test</code> and <code>stage: Prod</code>.</span></span></span>

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">After following the build workflow in the <code>azure-pipelines.yaml</code> file, you must have made at least two observations.
<strong>Observation 1:</strong> under both the jobs <code>job: plan</code> and <code>job: apply</code> (inside stages -Dev, Test, and Prod), I have included a <code>terraform init</code> task despite having initialized under the <code>stage: validate</code>.</span></span></span>

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><strong>Observation 2:</strong> The <code>terraform plan</code> task (inside <code>job: plan</code>) does not create a <code>tfplan file</code> for the <code>terraform apply</code> task (inside <code>job: apply</code>) to consume. That means, if there is a state change in the underlying infrastructure from the time the last <code>terraform plan</code> was run, review and approved, to the time the <code>terraform apply</code> was run, the plan applied may not be the same plan that was reviewed.</span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Let me explain that via an example. Say, at a <code>terraform plan</code> task step, based on the existing underlying infrastructure state, terraform created a list of resources and their desired states. <em>This list of resources and their desired states is known as a plan.</em> The following job is <code>job: approve</code> where someone reviews the list of resources and their desired states and based on what is required -resumes or rejects the job. While that is being reviewed, say someone else makes a change to the underlying infrastructure state. This state change is not captured in the review process of the previous step. Then, when <code>terraform apply</code> is run, it won't make the same state changes that were captured in the <code>terraform plan</code> task. <strong>But instead will take into consideration the state change that was made after the <code>terraform plan</code> was run.</strong> This renders the review process meaningless. The solution is to create the desired state file (aka <code>tfplan file</code>) at the terraform plan task. And then use the <code>tfplan file</code> in the <code>terraform apply</code> step. This approach ensures that plan file that is review is the same plan file that is applied to the underlying infrastructure. However, given that the time in the review stage is only 15 mins in the use case, the chances of an infrastructure state change are relatively low -but it is possible.</span></span></span>
<em><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">I came up with a few options that may address these two observations, and I have listed below the pros and cons of these approaches.</span></span></span></em>

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><strong>Option 1:</strong> No build artifact is created after stage: validate</span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">This is the current state of the <code>azure-pipelines.yaml</code> file.</span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Pros: (i) the approach is secure since no artifacts are accessible to anyone who may have read permission to the build pipeline.</span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Cons: (i) <code>terraform init</code> is run multiple times on the same code base, and (ii) no plan file is created, and hence the observation 2 becomes a concern.</span></span></span>

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><strong>Option 2:</strong> Create a build artifact after <code>stage: validate</code></span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Pros: (i) Run <code>terraform init</code> only once.</span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Cons :(i) The build artifact is heavy since it includes the <code>.terraform</code> folder that contains the provider package, and (ii) the build artifact also contains a state file that exposes the <code>secret access keys</code> that terraform uses to provision resources. As a result, anyone who has read permission to the build pipeline may access the keys. <strong>This is a security flaw.</strong></span></span></span>

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><strong>Option 3:</strong> Create a build artifact after <code>stage: validate</code> and create a <code>tfplan file</code> in <code>terraform plan</code> step and use that same <code>tfpan file</code> in the <code>terraform apply</code> step.</span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Pros: (i) Run <code>terraform init</code> only once, and (ii) address the concern raised in observation 2 above.</span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Cons: Same as the previous option.</span></span></span>

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">All the options mentioned above will work, and we have to choose the one that makes the most sense to us. There can also be variations to the above options to address the "cons" that I have raised. Like,<em> instead of creating a build pipeline artifact, the artifact may be stored in a shared folder with restricted access.</em> Whichever option is chosen, <strong>my advice would be to take security concerns very seriously.</strong></span></span></span>

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">I hope you found this note useful. Would you mind commenting if you believe I have missed or misstated something?</span></span></span>
