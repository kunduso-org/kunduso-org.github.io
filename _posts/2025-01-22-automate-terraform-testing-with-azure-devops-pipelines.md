---
title: "Automate Terraform Testing with Azure DevOps Pipelines"
date: 2025-01-22 13:50:09 +0000
categories: []
tags: []
---

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">HashiCorp introduced the <strong>Terraform testing framework</strong> with version <strong>1.06</strong> of Terraform. This note captures my experience learning and adding test cases to an existing Terraform configuration using <span style="text-decoration: underline">Azure DevOps Pipelines</span>. Along with my notes, you'll also find references to helpful guides and YouTube videos. By the end of this note, I want you to feel confident about implementing the Terraform testing framework for your Terraform configuration project.</span></span></span>
<!--more-->
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Testing in Terraform</strong> is crucial to ensure that infrastructure as code (IaC) is reliable, consistent, and safe to deploy. It helps catch errors early, improves confidence in the code's functionality, and <span style="text-decoration: underline">prevents issues in production environments later</span>. By leveraging the Terraform Testing framework, cloud engineering teams can automate and enforce best practices while avoiding potentially expensive mistakes.</span></span></span>

<strong><span style="font-size: 22px"><span style="font-family: calibri"><span style="color: #000000">The Guides</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I found the following two blogs and the three YouTube videos sufficient to use the Terraform testing framework.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Blogs:</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The best resource to start understanding the philosophy behind the Terraform testing framework is the <a href="https://www.hashicorp.com/blog/testing-hashicorp-terraform" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">HashiCorp Product &amp; Technology blog: Testing HashiCorp Terraform</span></span></span></a>. This blog offers in-depth insights into the testing capabilities of the framework. If you are short on time, please revisit the article later.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Another excellent resource is Mattias's blog  - <a href="https://mattias.engineer/blog/2023/terraform-testing-and-validation/" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">A Comprehensive Guide to Testing in Terraform: Keep your tests, validations, checks, and policies in order</span></span></span></a>.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">YouTube Videos:</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Apart from the detailed blog, there are three YouTube videos on the topic that I highly recommend. These are:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">1.</span></span></span><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><a href="https://www.youtube.com/watch?v=4U2S6sXcuac" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">Using the Terraform Test Framework by Ned Bellavance</span></span></span></a></span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">2. <a href="https://www.youtube.com/watch?v=AIeuhUB325A" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">Practical and inexpensive ways to test infrastructure deployments using Terraform by Gabe Maentz</span></span></span></a></span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">3. <a href="https://www.youtube.com/watch?v=oLRtFy6mYSg" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">Automating Tests for Terraform by KZ Li</span></span></span></a></span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Empowered by what I learned from the guides, I added the Terraform testing framework to the <a href="https://github.com/kunduso/terraform-aws-vpc" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">GitHub: terraform-aws-vpc</span></span></span></a> module. I have the high-level sections listed below.</span></span></span>

<strong><span style="font-size: 22px"><span style="font-family: calibri"><span style="color: #000000">Set-Up:</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Installer:</strong> Since HashiCorp introduced the Terraform testing framework with version <strong>1.0.6</strong>, I first upgraded the Terraform version on my local and then updated the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">azure-pipelines.yaml</code> file to install a version higher than that as part of the job.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Tests Folder:</strong> The Terraform testing framework, by default, expects the test cases to be in the tests folder when the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">terraform test</code> command is run. Hence, I created that folder to store the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">.tftest.hcl</code> files. In your case, if, due to specific reasons, the tests folder cannot exist there, then the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">terraform test</code> command will require an additional flag with <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">-test-directory=path-to-test-directory</code>.</span></span></span>

<strong><span style="font-size: 22px"><span style="font-family: calibri"><span style="color: #000000">Add Tests:</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Test configurations are written in HCL, and multiple <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">.tftest.hcl</code> files can exist in the test folder. These test files are executed alphabetically by filename. Each test configuration in a file has a <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">provider</code> block, a <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">variables</code> block, and one or more <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">run</code> blocks. You must have learned the purpose of these constructs from the reference guides above. At its core, the terraform testing framework uses the provider information, updates the variable's values, and then runs a <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">terraform plan</code> or <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">terraform apply</code> command based on the value specified inside the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">command</code> in a <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">run</code> block. Then, it uses the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">assert {}</code> block to compare if the value of a variable or property in the terraform plan or provisioned infrastructure matches with what is expected.</span></span></span>
<img class="alignnone size-full wp-image-5519" src="https://skdevops.wordpress.com/wp-content/uploads/2025/01/110-image-1.png" alt="110-image-1" width="831" height="425" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">For example, if you examine the above image, there are two <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">assert {}</code> blocks to check if the Amazon VPC was provisioned correctly. It does so because the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">command = apply</code> ensures the Amazon VPC was created in a specific AWS account. If an Amazon VPC exists, it'll have an ID and an ARN; the above two <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">assert {}</code> blocks are checking for that. You can find several testing constructs in the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">tests</code> folder in the GitHub repository.</span></span></span>

<strong><span style="font-size: 22px"><span style="font-family: calibri"><span style="color: #000000">Automate with Azure Pipelines:</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><span style="text-decoration: underline">Automated testing frameworks</span> allow cloud engineering teams to validate the Terraform configurations continuously, ensuring that infrastructure changes are safe and aligned with desired outcomes before deployment. By integrating testing into the CI/CD pipeline, teams can <span style="text-decoration: underline">catch issues earlier</span>, leading to faster, more reliable releases while maintaining the integrity of their infrastructure code. After adding the test cases, I automated the Terraform test framework via Azure Pipelines. The Azure Pipeline YAML consists of <span style="text-decoration: underline">three jobs: Validate, Test, and Provision</span>.</span></span></span>
<img class="alignnone size-full wp-image-5520" src="https://skdevops.wordpress.com/wp-content/uploads/2025/01/110-image-2.png" alt="110-image-2" width="1203" height="446" /><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The first job <strong>(Validate)</strong> runs the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">terraform init</code>, <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">terraform validate</code>, and the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">terraform fmt</code> checks to ensure that the Terraform configuration passes initialization (setting up the remote backend), ensures no syntax errors and provides consistent and standardized code style.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The second job <strong>(Test)</strong> runs parallel to the first job. I used a <span style="text-decoration: underline">separate AWS account</span> to test the Terraform configuration and was assured there wouldn't be any resource conflict between the two jobs. I added the new <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">job: Test</code> to the existing Azure Pipelines YAML.</span></span></span>
<img class="alignnone size-full wp-image-5521" src="https://skdevops.wordpress.com/wp-content/uploads/2025/01/110-image-3.png" alt="110-image-3" width="673" height="537" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">As you can examine the image above, there are only two steps in the job; not counting the installation step. The test cases stored in the tests folder at the root were executed alphabetically by filename. Within each test file, run blocks were executed sequentially in the order they appeared.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Here is an image of the test results in the <a href="https://littlecoding.visualstudio.com/Open-Project/_build?definitionId=37&amp;_a=summary" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">Azure DevOps Pipeline logs</span></span></span></a>. </span></span></span><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Please choose the latest run → Jobs → Test Terraform Configuration.</span></span></span>
<img class="alignnone size-full wp-image-5522" src="https://skdevops.wordpress.com/wp-content/uploads/2025/01/110-image-4.png" alt="110-image-4" width="1129" height="738" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">As you can examine, all 30 tests spread across the four <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">.tftest.hcl</code> files were successful.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Finally, the last job <strong>(Provision)</strong> was to create all the AWS cloud resources using the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">terraform apply</code> command, provided the branch was <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">main</code>. If you are interested in learning about using Terraform with Azure DevOps YAML pipeline, please refer to <a href="https://skundunotes.com/2021/02/17/azure-pipelines-yaml-and-terraform-to-provision-aws-s3/" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">azure-pipelines-yaml-and-terraform</span></span></span></a>. I enabled a condition in the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">job: Provision</code> such that it is enabled only when the previous two jobs pass.</span></span></span>
<img class="alignnone size-full wp-image-5523" src="https://skdevops.wordpress.com/wp-content/uploads/2025/01/110-image-5.png" alt="110-image-5" width="476" height="108" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Using the above steps, I enabled test cases for the <a href="https://github.com/kunduso/terraform-aws-vpc" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">GitHub: terraform-aws-vpc</span></span></span></a> module using Azure DevOps YAML pipelines. While creating this solution, I iterated over several best practices of this use case.</span></span></span>

<strong><span style="font-size: 22px"><span style="font-family: calibri"><span style="color: #000000">Best Practices with Terraform Test Cases</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Below are some best practices I implemented while writing Terraform test cases while provisioning AWS cloud resources:</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">1. Provision Cloud Resources in Separate AWS Accounts:</span></span></span></strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"> To ensure that the test cases do not interfere with production or other environments (e.g., Dev or Test), it is necessary to provision the test cloud resources in isolated AWS accounts. This segregation minimizes the risk of impacting the live environment during testing.</span></span></span>
<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">2. Automate Terraform Test Runs (via Pipeline): </span></span></span></strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"> Automating Terraform test executions through a CI/CD pipeline is essential. This ensures that the test cases run consistently and pass before any Terraform configurations are applied to a live environment in an AWS account (<code style="background-color: #dcdcdc;font-size: 15px;color: #000000">terraform apply</code>). Automation helps catch issues early in the process, reducing human error.</span></span></span>
<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">3. Include a run block with the apply command:</span></span></span></strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"> Ensure at least one run block with the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">command = apply</code> statement in your test cases. This ensures that you explicitly define the behavior of provisioning cloud resources, avoiding any surprises when deploying resources to Dev, Test, or Production environments.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">In conclusion, the Terraform testing framework <span style="text-decoration: underline">empowers the cloud engineering</span> team to ensure the high reliability and safety of Terraform configurations. I hope this note provided valuable insights and encouraged you to explore the Terraform Testing framework further.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">If you have any questions or suggestions, please use the comment section below. Given that this is a relatively new concept, your input on a few open questions would be particularly valuable:</span></span></span>
<ul>
 	<li><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Should the Terraform test be in a separate pipeline?</strong> Currently, I use a <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">job: Test</code> to execute the Terraform tests. Would a separate pipeline be more beneficial, or does it make sense to integrate the tests within an Azure Pipelines job that also handles configuration deployment?</span></span></span></li>
 	<li><strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">How often should the terraform test job run? </span></span></span></strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Should it run with every commit, and pull request, or only before the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">terraform apply</code> step? Or would it be prudent to run the tests with all these scenarios?</span></span></span></li>
 	<li><strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Should test configurations run in a separate AWS account or within the same account but in a different region? </span></span></span></strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">What are your thoughts on best practices for resource segregation during testing?</span></span></span></li>
 	<li><strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">How do we determine the extent of test case coverage for cloud resources?</span></span></span></strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"> Where should we draw the line regarding writing test cases for our infrastructure?</span></span></span></li>
</ul>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Your feedback will be insightful as I refine my understanding of implementing the Terraform testing framework.</span></span></span>
