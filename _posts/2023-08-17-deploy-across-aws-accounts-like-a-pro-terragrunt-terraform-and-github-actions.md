---
title: "Deploy Across AWS Accounts Like a Pro: Terragrunt, Terraform, and GitHub Actions"
date: 2023-08-17 19:55:36 +0000
categories: []
tags: []
---

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">In the past, I've written a note explaining the process of deploying the <a href="https://skundunotes.com/2023/03/07/ci-cd-with-terraform-and-github-actions-to-deploy-to-aws/" target="_blank" rel="noopener">Terraform IaC configuration into an AWS account using GitHub Actions</a>. In this note, I extend that functionality and deploy the same Terraform IaC configuration across <span style="text-decoration: underline">multiple AWS accounts using <strong>Terragrunt</strong> and <strong>GitHub Actions</strong>.</span></span></span></span>
<!--more--><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Before we delve deeper, let me briefly explain the <strong>four essential terms</strong> in the title of this note that we must understand  -AWS accounts, Terraform, Terragrunt, and GitHub Actions. Per <a href="https://docs.aws.amazon.com/accounts/latest/reference/accounts-welcome.html" target="_blank" rel="noopener">AWS-Docs</a>, an <strong>AWS account</strong> is the basic container for all the AWS resources you create as an AWS customer. <a href="https://www.terraform.io/" target="_blank" rel="noopener"><strong>Terraform</strong> </a>is a popular, easy-to-understand, and learn infrastructure-as-code tool that has accelerated the adoption of IaC principles. <a href="https://terragrunt.gruntwork.io/" target="_blank" rel="noopener"><strong>Terragrunt</strong></a> is a thin wrapper around Terraform that extends a few capabilities, primarily the ability to deploy Terraform configuration across multiple AWS accounts. And finally, <a href="https://github.com/features/actions" target="_blank" rel="noopener"><strong>GitHub Actions</strong></a> is an automation tool that makes it easy to carry out such activities  -manage authentication with AWS, deploy Terraform configuration, and manage environments.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">With Terraform, a project team manages its HCL code to provision resources and a set of commands to apply the HCL code to a specific AWS Account. In a very short period, developers learn to write HCL code to build and deploy the infrastructure. Terraform enables that via a few mandatory blocks of HCL code. These are <code>required_provider</code>, <code>provider</code>, and <code>backend</code>. The <code>backend</code> block stores the path to the <code>terraform state file</code>. It is optional but essential if the code is managed by multiple IaC engineers or automated via a CI-CD pipeline.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Here is an example code in the <code>backend</code> code block for the AWS Terraform provider.</span></span></span>
<img class="alignnone size-full wp-image-2799" src="https://skundunotes.com/wp-content/uploads/2023/08/80-image-1.png" alt="80-image-1" width="738" height="259" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">As you can see, the backend block stores three critical pieces of information  -the <code>S3 bucket</code>, the <code>key</code> to the .tfstate file, and the <code>region</code> of the S3 bucket.</span></span></span>

<strong><span style="font-size: 20px"><span style="font-family: calibri"><span style="color: #000000">Challenge:</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Generally, when a project team works on an application, they want <strong>multiple environments</strong> to test it -Dev (short for development), Test, Prod (short for production), etc. And a project team would prefer as much environmental isolation as possible. One technique to isolate the environment is through <strong>separate AWS accounts</strong>. And Terraform can be used to provision infrastructure across individual AWS accounts. But when it comes to creating the infrastructure for these environments in the individual AWS accounts, there are <strong>two considerations:</strong></span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">(a) the code in the Terraform <strong>backend block cannot have variables</strong>, and</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">(b) the bucket names are <strong>unique across all the AWS accounts</strong>.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">If variables were allowed in the backend code for the <code>S3 bucket</code>, <code>key</code>, and <code>region</code>, we could set that to separate values for separate AWS accounts. Similarly, if the bucket names were not unique across AWS accounts, we could have had the same name across different AWS accounts, and there would be no conflict. <span style="text-decoration: underline">And hence, using Terraform to deploy the same code without repeating it across separate AWS accounts becomes challenging.</span></span></span></span>

<strong><span style="font-size: 20px"><span style="font-family: calibri"><span style="color: #000000">Solution:</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">A solution to extending the usage of Terraform code across different AWS accounts is to <strong>generate the backend block dynamically at runtime</strong>. An IaC engineer can <strong>pass variables</strong> and develop the Terraform code to work across separate AWS accounts by generating the backend block at runtime. And that is <span style="text-decoration: underline">one of the use cases that Terragrunt addresses</span>. Using <strong>Terragrunt</strong>, IaC engineers can use the same <strong>Terraform configuration across multiple AWS accounts</strong> without repeating the code. Terragrunt can also be used in a<strong> CI-CD pipeline</strong>.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">In this note, I demonstrate how to use <strong>Terragrunt to deploy the same Terraform configuration code</strong> (with environment-specific configurations) across <strong>two separate AWS accounts using GitHub Actions</strong>. The process can be classified into <strong>three high-level steps.</strong> These are:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>1.</strong> Create the pre-requisites in AWS and GitHub Actions,</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>2.</strong> Add the environment-specific Terragrunt HCL code to the GitHub repository, and</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>3.</strong> Run the HCL code via GitHub Actions.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Before I start explaining the workflow, there are a few essential concepts regarding <strong>Terragrunt</strong> that I want to mention. These are as follows.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><code>include{}</code>  -all the HCL files relevant to an environment</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><code>inputs{}</code>  - the environment-specific values of the infrastructure</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><code>terraform{}</code>  -the path to the terraform code where the .tf files are stored, and</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><code>remote_state{}</code>  -the S3 bucket, the key, and the region to store the terraform configuration. An exciting feature is that Terragrunt will <span style="text-decoration: underline">create the S3 bucket</span> if it does not exist. Same for the <span style="text-decoration: underline">Amazon Dynamodb table</span>.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">It is best to review these concepts via a working example. Check out my <a href="https://github.com/kunduso/add-aws-elb-ec2-private-subnet-terraform-live" target="_blank" rel="noopener">GitHub repository: add-aws-elb-ec2-private-subnet-terraform-live</a>, where I have functional code.</span></span></span>

<strong><span style="font-size: 20px"><span style="font-family: calibri"><span style="color: #000000">GitHub Repository Layout:</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">There are two top-level folders - <code>.github</code> folder to store the pipeline workflow YAML files and the <code>environment</code> folder to store the environment-specific (dev and test) HCL configuration. I could have had another folder in the GitHub repository as infrastructure and kept the terraform code (.tf files) in the same repository; I do not have it that way. Instead, I am <em>(partially)</em> following the recommendations made in the article  -<a href="https://github.com/gruntwork-io/terragrunt-infrastructure-live-example" target="_blank" rel="noopener">infrastructure-live for Terragrunt</a>, where the Terraform code is stored independently of the Terragrunt configuration.</span></span></span>

<strong><span style="font-size: 20px"><span style="font-family: calibri"><span style="color: #000000">AWS Account Layout:</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I have two separate AWS accounts for each Dev and Test environment. I have an Automation AWS account (DevOps) that hosts a role (<code>role/devops-automation</code>) to manage the deployments to the two AWS accounts.</span></span></span>
<img class="alignnone size-full wp-image-2800" src="https://skundunotes.com/wp-content/uploads/2023/08/80-image-2.png" alt="80-image-2" width="816" height="406" />
<strong><span style="font-size: 20px"><span style="font-family: calibri"><span style="color: #000000">1. Create the pre-requisites in AWS and GitHub Actions</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Since I follow the setup above  -a central automation account and two separate accounts for each environment- there are a few prerequisites to arrange before I can let the <strong>GitHub Actions automation</strong> run. These are:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>(a)</strong> Configure <strong>OpenID Connect</strong> in the Automation AWS account to authenticate with GitHub actions,</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>(b)</strong> Create a role with appropriate permissions in the target AWS account (Dev and Test),</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>(c)</strong> Set up a trust relation between the AWS IAM roles (automation account and dev account roles and automation account and test account roles), and</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>(d)</strong> Create Environments in GitHub for each product environment.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Let me now expand on each of these steps, starting with:</span></span></span>
<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">(a) Configure OpenID Connect in the Automation AWS account</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I use OpenID Connect to authenticate the GitHub Actions workflow and store the ARN of the role as a GitHub secret. If you are new to OpenID Connect and want to learn how to set that up, head over to   -<a href="https://skundunotes.com/2023/02/28/securely-integrate-aws-credentials-with-github-actions-using-openid-connect/" target="_blank" rel="noopener">securely-integrate-aws-credentials-with-github-actions-using-openid-connect</a>. In a short span, you will be able to set that up yourself. I captured the trust relationship of the role in the below image. Your IAM role's trusted entities must look similar except for the AWS account number and the GitHub repository name.</span></span></span>
<img class="alignnone size-full wp-image-2801" src="https://skundunotes.com/wp-content/uploads/2023/08/80-image-3.png" alt="80-image-3" width="902" height="452" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Then, I use the below code in GitHub Actions to configure the credentials. The value of role-to-assume is the ARN of the role that I stored as a GitHub secret.</span></span></span>
<img class="alignnone size-full wp-image-2802" src="https://skundunotes.com/wp-content/uploads/2023/08/80-image-4.png" alt="80-image-4" width="646" height="118" />
<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">(b) Create a role with appropriate permissions in the target (Dev and Test) AWS accounts</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">In each AWS account (Dev and Test), create an IAM role with a permissions policy and a trust relationship with the Automation AWS account. I am not going into the details of how to create a role, but at a high level, when you launch IAM -&gt; Roles -&gt; Create Role and select the Trusted entity type as AWS account and select "Another AWS account," and copy the AWS account number of the automation AWS account. After that, choose a permission policy that supports the Terraform configurations in the project. Select or create a reasonably tight permissions policy or go with the AWS-managed <code>AdministratorAccess</code>, which I would not encourage due to security concerns. After creating the role, edit the trusted entities and tighten that up.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">When you create the role via the AWS console, the trusted entities will look like below:</span></span></span>
<img class="alignnone size-full wp-image-2803" src="https://skundunotes.com/wp-content/uploads/2023/08/80-image-5.png" alt="80-image-5" width="552" height="223" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Change that to:</span></span></span>
<img class="alignnone size-full wp-image-2804" src="https://skundunotes.com/wp-content/uploads/2023/08/80-image-6.png" alt="80-image-6" width="715" height="296" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Please ensure you have the correct AWS account number and the role name.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">As you can see, the updated trusted entity is tighter than the previous one since it enables <code>sts:AssumeRole</code> to only the <code>role/devops-automation</code> entity in the specified AWS account.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">After creating the Dev AWS account role, I repeated the above step for the Test AWS account.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">(c) Set up a trust relation between the AWS IAM roles</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I completed half of the trust set up in the previous step. In this step, I enabled the role created in (a) to assume the roles in the Dev and Test AWS accounts. This is what the permission policy of the <code>devops-automation</code> role in the Automation AWS Account looked like at the end:</span></span></span>
<img class="alignnone size-full wp-image-2805" src="https://skundunotes.com/wp-content/uploads/2023/08/80-image-7.png" alt="80-image-7" width="732" height="327" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">That is all required to set up the trust relationship. For the next step, head over to GitHub.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>(d)</strong> <strong>Create Environments in GitHub for each product environment</strong></span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">On your GitHub repository page, navigate to the Settings Tab at the top. Then, search for Secrets and variables on the left-hand vertical pane, open the menu, and select Actions.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Following the first step under (a), you would already have a repository secret with the IAM_ROLE name and secret value. There is also a provision to manage Environments here. Click on Manage environments  -&gt; New environment  -&gt; Name it as "Development"  -&gt; Configure environment.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Please create a new environment secret as <code>ACCOUNTNUMBER</code> and store the AWS account number as its value. Repeat the same for the Test AWS accounts. I also stored the value of <code>AWS_REGION</code> as an environment variable.</span></span></span>
<em><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Please note: The name you give to an environment here must map with the terragrunt.yml file in the .github\workflow folder.</span></span></span></em>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">And that brings us to the end of all setup-related activities. Next, I will show how to create the configuration for each environment.</span></span></span>

<strong><span style="font-size: 20px"><span style="font-family: calibri"><span style="color: #000000">2. Add the environment-specific Terragrunt HCL code to the GitHub repository</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Navigate to the environments folder in the <a href="https://github.com/kunduso/add-aws-elb-ec2-private-subnet-terraform-live" target="_blank" rel="noopener">GitHub repository</a>. You will see that I have two top-level folders in the "environment" folder: dev and test, corresponding to the two environments. I have a region-specified folder inside these folders with the <code>terragrunt.hcl</code> file for each environment. There are three Terragrunt constructs used in the file which I discussed above  -<code>include{}</code>, <code>terraform{}</code>, and <code>inputs{}</code>. </span></span></span><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">For all the standard code across all the environments, I stored them in the <code>common.hcl</code>, which is at the root of the repository. </span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The <code>common.hcl</code> declares how to generate the <code>provider</code> and the <code>remote_state</code> to store the state file. You will also see that I specified the bucket as <code>terraform-remote-state-${get_aws_account_id()}</code>, which would be a unique bucket for each environment since the account number is unique per AWS account. Also, using the repository name and the <code>path_relative_to_include()</code> Terragrunt function enables us to maintain a unique path to the state file. This approach is beneficial if multiple GitHub repositories deploy to the same AWS account.</span></span></span>

<strong><span style="font-size: 20px"><span style="font-family: calibri"><span style="color: #000000">3. Run the HCL code via GitHub Actions</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Finally, we're at the last section, which is to provision infrastructure for a specific environment. The code to deploy the Terraform configuration is in the <code>.github\workflows</code> folder. Since deploying to multiple environments is the same, I am utilizing a reusable workflow. You can read about that at  -<a href="https://github.blog/2022-02-10-using-reusable-workflows-github-actions/" target="_blank" rel="noopener">using-reusable-workflows-github-actions</a>. In my code, the deployment to the Dev and Test environment is one after the other, provided the previous deployment passed, and the gate was approved. The sequencing of deployment (one after the other) is managed using the <code>needs</code> keyword in the <code>jobs</code> code block, and the reusable workflow is managed via the <code>uses</code> keyword. Also, how is Terragrunt deploying the code to a specific AWS account? That is managed via the  <code>--terragrunt-iam-role</code> for each <code>terragrunt command</code> in the <code>deploy.yml</code> workflow file. The role points to an IAM role ARN with a variable, the ACCOUNTNUMBER, and if you remember, we added that to the GitHub environment secret. And the environment is selected in the <code>terragrunt.yml</code> jobs that call the <code>deploy.yml</code> workflow.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Here is a link to a <a href="https://github.com/kunduso/add-aws-elb-ec2-private-subnet-terraform-live/actions/runs/5893866620" target="_blank" rel="noopener">GitHub Actions workflow</a> that deployed the Terraform configuration successfully to the Dev and Test environments.</span></span></span>
<img class="alignnone size-full wp-image-2814" src="https://skundunotes.com/wp-content/uploads/2023/08/80-image-8.png" alt="80-image-8" width="876" height="440" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">As you can see from the GitHub Actions run, it was deployed to the Dev and Test AWS accounts. If you navigate the <code>environment</code> folder in the GitHub repository, you will see that the two environments have different Terraform resource values. Below is an image of the <code>terragrunt.hcl</code> file in the <code>environment\dev\us-east-2\infra</code> folder.</span></span></span>
<img class="alignnone size-full wp-image-2815" src="https://skundunotes.com/wp-content/uploads/2023/08/80-image-9.png" alt="80-image-9" width="1008" height="157" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The configuration values are different if you compare that against the code in the Terraform source repository. Similarly, take a look at the <code>terragrunt.hcl</code> file in the <code>environment\test\us-east-1\infra</code> folder below:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><img class="alignnone size-full wp-image-2816" src="https://skundunotes.com/wp-content/uploads/2023/08/80-image-10.png" alt="80-image-10" width="993" height="209" /></span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The values are different from the dev version. You can also see that I added additional values (<code>availability_zone</code> and <code>instance_type</code>). This approach demonstrates that by using Terragrunt, I could manage separate environment configurations without repeating all the Terraform code.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">And that brings us to the end of this note. Using Terragrunt, we can use the same Terraform code with <span style="text-decoration: underline">separate variable values</span> for separate environments hosted in separate AWS accounts. And the process is automated using GitHub Actions. Here are some additional concepts we explored:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">-configure <strong>OpenID Connect</strong> with AWS and manage GitHub Actions deployment into AWS without storing secure credentials</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">-create a <strong>trust relationship</strong> between AWS accounts using roles</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">-create <strong>environments in GitHub</strong> to store secrets securely</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">-add environment-specific <strong>Terragrunt</strong> HCL code</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">-run the <strong>Terraform code</strong> with separate values for separate environments</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">-work with <strong>reusable workflow</strong> in GitHub Actions</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">-protect deployments to upper environments using <strong>approval gates</strong></span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">This note and the GitHub repository have everything you need to <strong>start working with Terragrunt</strong>. So please go ahead and fork the repository and start creating your deployment. If you have any questions, please do not hesitate to contact me. Same for suggestions as well.</span></span></span>
