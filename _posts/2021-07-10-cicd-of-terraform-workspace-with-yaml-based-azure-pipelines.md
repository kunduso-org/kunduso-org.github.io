---
title: "CI/CD of Terraform workspace with YAML based Azure Pipelines"
date: 2021-07-10 12:49:22 +0000
categories: []
tags: []
---

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">This note focuses on using Azure DevOps with Terraform workspace to automate the ideas discussed in the previous two notes (i) <a href="https://skundunotes.com/2021/06/18/ci-cd-using-terraform-and-azure-pipelines-ideation/" target="_blank" rel="noopener">CI/CD using Terraform and Azure Pipelines -ideation</a> and (ii) <a href="https://skundunotes.com/2021/06/19/terraform-workspace-with-multiple-aws-accounts/" target="_blank" rel="noopener">Terraform workspace with multiple AWS accounts</a>. If you are new to Azure DevOps, I would suggest you familiarize yourself with either Azure DevOps build and release definition concepts or Azure Pipelines if you are using YAML builds.</span></span></span>
<!--more-->
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">In my previous note (Terraform workspace with multiple AWS accounts), I discussed a use case to provision Amazon VPCs in separate AWS accounts. I will be building on the same use case in this note, using YAML-based Azure Pipelines.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The approach I suggested earlier was to have <code>terraform init</code> and <code>terraform validate</code> run in a CI build definition and have the <code>terraform plan</code> and <code>terraform apply</code> run inside a CD release definition. However, while using <code>terraform workspace</code> I must select a workspace and then run a <code>terraform validate</code> against that particular workspace. Furthermore, in the case of multiple workspaces, I must run <code>terraform validate</code> against all the workspaces.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">In such a situation, I tweaked the build algorithm to be as below:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Step 1:</strong> Provide the build agent with terraform configuration files and a "list of workspaces" to validate the configuration against</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Step 2:</strong> Run <code>terraform init</code> (this command would be run against the default workspace)</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Step 3:</strong> For each workspace provided in the list of workspaces (in step 1), check if the workspace exists and if it does not, create the workspace</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Step 4:</strong> Validate the selected workspace</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Step 5:</strong> Repeat steps 3 and 4 until all workspaces specified in the "list of workspaces" are validated.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Step 6:</strong> Create a build artifact</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Then on the CD side, for each Stage (Dev, Test, and Prod), run the following:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Step 1:</strong> Download the build artifact</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Step 2:</strong> Select a particular workspace</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Step 3:</strong> Run <code>terraform plan</code> against that workspace</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Step 4:</strong> Wait for manual validation (reject or resume) of the plan file created in Step 3</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Step 5:</strong> If step 4 was a resume, run <code>terraform apply</code></span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I started on the above approach, but instead of using the classic editor,<strong> I chose the YAML-based pipelines.</strong> Why? Because the YAML-based pipeline can be versioned and committed to the same code repository where the rest of the terraform configuration files reside. Storing the YAML build definition alongside the code allows someone to clone the code repository and have a running pipeline ready in no time because they'd gain access to the build pipeline too. I have a separate note on my views on <span style="text-decoration: underline"><a href="https://skundunotes.com/2020/05/15/getting-started-with-azure-devops-create-a-build-pipeline-part-1-yaml-pipeline/" target="_blank" rel="noopener">YAML based Azure pipelines</a></span>.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The other benefit of using a YAML-based Azure pipeline was <strong>merging the CI-CD into a single Azure pipeline</strong>. In the classic editor of Azure DevOps, I could manage only the CI steps in a build definition and create an artifact for the release definition to deploy. However, in the case of Azure pipelines, I could use <code>Stages</code> to implement the workflow of CI and CD both. I believe these concepts are best explained via an example.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I have a working code committed to my Github repo <span style="text-decoration: underline"><a href="https://github.com/kunduso/Working-with-Terraform-workspace-and-AWS" target="_blank" rel="noopener">Working-with-Terraform-workspace-and-AWS</a></span> along with an associated <code>azure-pipelines.yaml</code> file.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The process flow in the <code>azure-pipelines.yaml</code> file is a slight tweak of the one described above. There are <code>stages</code>, and inside that there are <code>jobs</code>, and inside, there are <code>steps</code>, and inside, there are <code>tasks</code>.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The first <code>Stage: Validate</code> has a <code>job: init</code>, which has two tasks:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Task #1: run <code>terraform init</code></span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Task #2: run <code>terraform validate</code> using a Powershell script.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The Powershell script (<code>ValidateWorkspace.ps1</code>) takes a "comma-separated list of values" as the parameter, which is the list of workspaces that have to be validated. It then iterates through the list and checks if the workspace is available/created; if not, it creates the workspace. Then it runs <code>terraform validate</code> against that workspace. These are the steps that I planned to include in the build algorithm.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The next three Stages: Dev, Test, and Prod, are pretty identical except for the workspace where they run. Each of these stages is divided into three jobs: plan, approve and apply.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The <code>job: plan</code> is broken down into three tasks:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Task #1:</strong> run <code>terraform init</code></span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Task #2:</strong> select the correct workspace</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Task #3:</strong> run <code>terraform plan</code></span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">At the end of task# 3, terraform displays the changes that will be applied to the environment. Then, I introduced another <code>job: approve</code>, which is a manual validation for looking at the plan and resume or reject that. If the plan seems correct, then the validation is resumed, else rejected. If rejected, the pipeline exits. If resumed, the next <code>job: apply</code> starts.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The last <code>job: apply</code> has three tasks:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Task #1: run <code>terraform init</code></span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Task #2: select the correct workspace</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Task #3: run <code>terraform apply</code></span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">On successful completion of <code>stage: Dev</code>, the next <code>stage: Test</code> starts, and the same set of jobs and tasks are run. However, the workspace is updated to <code>Test</code>  and, similarly, for <code>stage: Prod</code> where the workspace is <code>Prod</code>.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I have the link to the <span style="text-decoration: underline"><a href="https://littlecoding.visualstudio.com/Open-Project/_build/results?buildId=185&amp;view=results" target="_blank" rel="noopener">Azure pipelines build log</a></span> to check the different stages, jobs, and tasks applied using the <code>azure-pipelines.yaml</code> file (expand the Dev, Test, and Prod stages to view details of the jobs run inside them). Here is an image of the pipeline stages.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><img class="alignnone size-full wp-image-1347" src="https://skundunotes.com/wp-content/uploads/2021/07/44.-image-3.png" alt="44. image-3" width="904" height="279" /> </span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Not to forget, the terraform state files of all these stages (which are workspaces in terraform parlance) are stored separately. For example, here is an image of the workspace: Dev state file.</span></span></span>
<img class="alignnone  wp-image-1346" src="https://skundunotes.com/wp-content/uploads/2021/07/44.-image-4.png" alt="44. image-4" width="665" height="351" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">As you can see, the path to the state file is <code>Amazon S3/skundu-terraform-remote-state-two/env:/Dev/tf/terraform.tfstate</code></span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The state file for <code>workspace: Test</code> is stored at <code>Amazon S3/skundu-terraform-remote-state-two/env:/Test/tf/terraform.tfstate</code></span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Where are these values set? Check the <code>backend.tf</code> file in the repository.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">And that brings us towards the end of this exciting concept of terraform workspace and how to automate that using Powershell and <code>azure-pipelines.yaml</code></span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I ideated on the concept of being able to apply the same terraform configuration across separate environments in my first note. And using terraform workspace I was able to achieve that. <strong>However, there is a security observation I want to make.</strong> The state files of all the environments (AWS Accounts) are stored in the same Amazon S3 bucket of the trusted account. It might be acceptable for specific organizations. However, <em>I believe the state file of these environments should be stored separately, possibly, in the same account where the infrastructure is provisioned.</em> Either way, whatever decision an organization decides on, <em>they should align with the organization's security and compliance principles.</em></span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">PS: While working on the <code>azure-pipeline.yaml</code> file, I identified a few alternate routes possible, and I discussed them in a later note  -<a href="https://skundunotes.com/2021/07/18/yaml-based-azure-pipeline-approach-for-ci-cd-of-terraform-workspace/" target="_blank" rel="noopener">YAML based Azure Pipeline approach for CI/CD of Terraform workspace</a>.</span></span></span>
