---
title: "Create AWS Lambda Layer using Docker, Terraform and GitHub Actions"
date: 2024-09-29 12:04:00 +0000
categories: []
tags: []
---

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>A Lambda layer</strong> is a distribution mechanism for libraries, custom runtimes, or other dependencies required in the AWS Lambda functions. Cloud engineers can <span style="text-decoration: underline">manage and reuse these libraries</span> and dependencies across multiple functions by packaging them into a layer. By the end of this note, <span style="text-decoration: underline">you will learn how to create a Lambda layer for a Python library</span> and share it with all the AWS accounts in the organization.</span></span></span>
<!--more-->
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">There are <span style="text-decoration: underline">three primary benefits</span> of using a Lambda layer. These are:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">1. Lambda layers <span style="text-decoration: underline">promote code reuse</span>, allowing applications to share libraries and dependencies across multiple functions to simplify management.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">2. Layers <span style="text-decoration: underline">enable version control</span>, allowing cloud engineers to maintain and roll back to specific versions of dependencies as needed.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">3. Layers <span style="text-decoration: underline">encourage standardization of dependencies</span> and ensure consistency across different functions, minimizing compatibility issues and improving reliability.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">In this note, I'll demonstrate how to create a Lambda layer using Docker, Terraform, and GitHub Actions.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">But why use the Lambda layer?</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The AWS Lambda service comes with a set of built-in libraries in its runtime environment. If you used the service for Python, you might have encountered the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">boto3</code>, <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">json</code>, and <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">logging</code> Python libraries. These are examples of built-in Python libraries; cloud engineer teams are not required to supply the library/ies with the Python file/s. So, while the AWS Lambda runtime contains a few libraries, many more need to be included based on the use case. The Lambda layer is a mechanism the AWS cloud service offers to <span style="text-decoration: underline">add such libraries that aren't included in the Lambda runtime environment</span>, enabling error-free execution of the Python functions.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">A Lambda layer can consist of one or many libraries. In the Python runtime, <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">numpy</code>, <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">pandas</code>, and <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">requests</code> are some example libraries.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">While proposing using the AWS Lambda layer, an alternate approach is to package the Python code with the libraries and upload the package to AWS Lambda.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">However, cloud engineering teams can effectively manage dependencies and share libraries across multiple AWS Lambda functions using Lambda layers. This modular approach allows the project teams to keep the AWS Lambda function code clean and lightweight, streamline the update process for shared libraries, and improve the overall maintainability of the serverless applications.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Platform mismatch</strong> is a common issue when developing Python applications for AWS Lambda that require a library that is unavailable in the Lambda runtime. For example, if you're using Windows to install Python3 packages via <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">pip3</code>, the resulting binaries are tailored for the Windows environment. However, AWS Lambda runs on a Linux-based environment (specifically Amazon Linux), often leading to compatibility issues. Libraries that rely on compiled extensions or native dependencies can fail to work when deployed to AWS Lambda (either as a package with the Python code or as a Lambda layer), as they may not be compatible with the underlying Linux OS. Creating a deployment package (Python libraries) in a Linux environment (such as Docker) is advisable to avoid incompatibility. This approach ensures that the libraries operate correctly in the serverless environment.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">In my quest for a solution, I found the following article from <a href="https://www.capitalone.com/tech/cloud/creating-lambda-layers/" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">CapitalOne: Creating Lambda Layers</span></span></span></a>.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I recommend that you follow the steps articulated in that article. If you are interested and want to learn how I created an AWS Lambda layer following the guidance, please continue to read. I have the Terraform code in my <a href="https://github.com/kunduso/aws-lambda-layer-terraform" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">GitHub repository: kunduso/aws-lambda-layer-terraform</span></span></span></a>.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">You must <strong>install Docker</strong> on your local laptop and decide on the Python3 version for the AWS Lambda runtime. The AWS Lambda service currently supports Python3.9 to Python3.12 (support for Python 3.8 ends by October 2024).</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">1. Build the Docker Image</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">As suggested in the referenced article, the first step is to access the <a href="https://github.com/aws/aws-lambda-base-images" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">GitHub repository: aws-lambda-base-images</span></span></span></a> and then clone it to your local. Having a copy (fork) of the GitHub repository might also be a good idea. Please also utilize this opportunity to go through the <span style="text-decoration: underline">repository ReadMe</span>. You will learn why this repository exists and how AWS plans to help the development community.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">After cloning the GitHub repository, I selected the appropriate branch based on the Python runtime. On this note, I am demonstrating with Python3.10, and hence, I checked out that branch <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">git checkout python3.10</code></span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Then, I followed the reference article's suggestion and commented on the last line in the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">Dockerfile.python3.10</code> file.</span></span></span>
<img class="alignnone size-full wp-image-4813" src="https://skundunotes.com/wp-content/uploads/2024/09/102-image-1.png" alt="102-image-1" width="884" height="418" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Then, I built the image from the Dockerfile using the following command:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><code style="background-color: #dcdcdc;font-size: 15px;color: #000000">docker build -t aws-python3.10:local -f Dockerfile.python3.10 .</code></span></span></span>
<img class="alignnone size-full wp-image-4814" src="https://skundunotes.com/wp-content/uploads/2024/09/102-image-2.png" alt="102-image-2" width="622" height="350" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">That created a Docker image called <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">aws-python3:10:local</code> in the Docker desktop instance running on my laptop.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">2. Create a directory for the Python libraries</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Per the reference article, the next step is to create the Python directory to store the libraries. In this use case, I am referencing two GitHub repositories. Repository#1 is <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">aws-lambda-base-images</code> where I executed the Docker commands and created the Docker image. Repository#2 is <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">aws-lambda-layer-terraform</code> where I have the Terraform code and the Python3.10 libraries to create the Lambda layer.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">After creating the Docker image from the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">aws-lambda-base-images</code> repository, I accessed the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">aws-lambda-layer-terraform</code> repository in another VS Code window and created the Python directory. The below image shows where I created the folder. Please note that the top-level folder (layer3.10) could have any name, but the root folder must be named <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">python</code>. That is an AWS requirement. For more information, please refer to <a href="https://docs.aws.amazon.com/lambda/latest/dg/packaging-layers.html#packaging-layers-paths" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">packaging-layers-path</span></span></span></a>.</span></span></span>
<img class="alignnone size-full wp-image-4815" src="https://skundunotes.com/wp-content/uploads/2024/09/102-image-3.png" alt="102-image-3" width="428" height="472" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Per the reference article, the author created a <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">requirements.txt</code>. I was using only one Python3 library -<code style="background-color: #dcdcdc;font-size: 15px;color: #000000">psycopg2</code> and hence skipped that step.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">3. Create a Docker container</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Then, I executed the following step from my GitHub repository:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><code style="background-color: #dcdcdc;font-size: 15px;color: #000000">docker run --name customlayer --rm --env HTTP_PROXY --env HTTPS_PROXY --env NO_PROXY --mount type=bind,source="$(pwd)"/layer3.10,target=/var/task/lambdalayer -it aws-python3.10:local bash</code> and that provided me the interactive terminal to access the container's shell.</span></span></span>
<img class="alignnone size-full wp-image-4816" src="https://skundunotes.com/wp-content/uploads/2024/09/102-image-4.png" alt="102-image-4" width="871" height="75" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Using this step, I created the runtime used by the AWS Lambda service. </span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">4. Install the required Python3 libraries</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The following command was to navigate to the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">python</code> folder and then install the library:</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><code style="background-color: #dcdcdc;font-size: 15px;color: #000000">pip3 install --target=. --only-binary=:all: --upgrade psycopg2-binary</code></span></span></span>
<img class="alignnone size-full wp-image-4817" src="https://skundunotes.com/wp-content/uploads/2024/09/102-image-5.png" alt="102-image-5" width="865" height="230" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Then, after removing all the unnecessary files and folders (cache, docs), I reviewed the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">python</code> folder to find the required libraries.</span></span></span>
<img class="alignnone size-full wp-image-4818" src="https://skundunotes.com/wp-content/uploads/2024/09/102-image-6.png" alt="102-image-6" width="329" height="355" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">With the packages available, I exited the container interactive terminal by typing <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">exit</code>.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">At this point, I no longer required the container for this use case. </span></span></span><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">I also stopped following the reference article because I used Terraform to create the Lambda layer.</span></span></span>

<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">5. Terraform: </span></span></span></strong><strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">Create a Lambda layer</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The Terraform code creates a zip file with the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">python</code> folder inside and then creates a Lambda layer. Although you can have multiple compatibility runtimes, I have noticed that, at least for the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">psycopg2</code> library, if the library is built with the Python3.10 version, it does not work with any other runtime. <span style="text-decoration: underline">Hence, having a 1:1 mapping between the compatibility runtimes and the layers is cleaner.</span></span></span></span>
<img class="alignnone size-full wp-image-4819" src="https://skundunotes.com/wp-content/uploads/2024/09/102-image-7.png" alt="102-image-7" width="803" height="307" />
<strong><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">6. Terraform: Share the Lambda layer with the organization</span></span></span></strong>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">The beauty of AWS Lambda layers is that they can be <span style="text-decoration: underline">shared across different AWS accounts</span> within the same AWS region. This feature promotes collaboration and reusability, allowing teams to utilize libraries and dependencies <span style="text-decoration: underline">without duplication</span>.</span></span></span>
<img class="alignnone size-full wp-image-4820" src="https://skundunotes.com/wp-content/uploads/2024/09/102-image-8.png" alt="102-image-8" width="917" height="263" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">You will notice that I am using a variable for the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">organization_id</code>. Since it is a sensitive value, it is stored as a GitHub Actions secret and passed to Terraform during the <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">plan</code> and <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">apply</code> step in the pipeline. If you implement the solution for your organization, you can access the value from the AWS Console → AWS Organizations. The value would be a regular expression pattern: <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">o-[a-z0-9]{10,32}</code>.</span></span></span>
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000"><strong>Terraform and GitHub Actions</strong> create the Lambda layer after the code is committed and pushed to a remote repository. I have a separate note on automating the provisioning process for AWS cloud resources using GitHub Actions.</span></span></span>
<img class="alignnone size-full wp-image-4821" src="https://skundunotes.com/wp-content/uploads/2024/09/102-image-9.png" alt="102-image-9" width="722" height="367" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">If you want to learn how I managed the authentication process, head over to this note <a href="https://skundunotes.com/2023/02/28/securely-integrate-aws-credentials-with-github-actions-using-openid-connect/" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">–securely-integrate-aws-credentials-with-github-actions-using-openid-connect</span></span></span></a>. I also scanned my code for <span style="text-decoration: underline">vulnerabilities using Bridgecrew Checkov</span>, which generated a scan report. Here is a note on how to <a href="https://skundunotes.com/2023/04/12/automate-terraform-configuration-scan-with-checkov-and-github-actions/" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">enable Checkov with GitHub Actions</span></span></span></a>. I'm also interested in the cost of these resources and use <span style="text-decoration: underline">Infracost</span> for that, which I have covered in detail in this note – <a href="https://skundunotes.com/2023/07/17/estimate-aws-cloud-resource-cost-with-infracost-terraform-and-github-actions/" target="_blank" rel="noopener"><span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #0000ff">estimate AWS resource cost</span></span></span></a>. The vulnerabilities and cost estimate are available in the pull request as comments.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">After the Lambda layer and the layer permission were created, any AWS Lambda function from any AWS Organization accounts could reference them. And there is a caveat to how the layer is referenced from the resource <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">aws_lambda_function</code>.</span></span></span>

<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">If you are referencing the Lambda layer in the same AWS account where it is created, you may access it via the Terraform <code style="background-color: #dcdcdc;font-size: 15px;color: #000000">data {}</code> construct. However, if you are accessing it from another AWS account (member of the AWS Organizations), the complete ARN has to be used in the Lambda layer. Hence, the reference will look similar to the one below:</span></span></span>
<img class="alignnone size-full wp-image-4822" src="https://skundunotes.com/wp-content/uploads/2024/09/102-image-10.png" alt="102-image-10" width="795" height="103" />
<span style="font-size: 18px"><span style="font-family: calibri"><span style="color: #000000">That brings us to the end of this note. Since you can access both GitHub code repositories, try provisioning the AWS cloud resources. Let me know if you have any questions or suggestions.</span></span></span>
