---
title: "Getting started with Azure Devops -create a build pipeline -Part 2 (Classic Editor)"
date: 2020-05-15 21:00:08 +0000
categories: []
tags: []
---

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">This is <strong>part 6 of a multipart series on getting started with Azure DevOps</strong>. Please refer to the below links to access other notes in this series.</span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><a href="https://skundunotes.com/2019/11/07/getting-started-with-azure-devops/" target="_blank" rel="noopener">Part 1: Getting started with Azure DevOps</a></span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><a href="http://skundunotes.com/2019/12/24/getting-started-with-azure-devops-work-items/" target="_blank" rel="noopener">Part 2: Getting started with Azure DevOps -work items</a></span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><a href="http://skundunotes.com/2020/03/17/getting-started-with-azure-devops-add-a-repo/" target="_blank" rel="noopener">Part 3: Getting started with Azure DevOps -add a repo</a></span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><a href="http://skundunotes.com/2020/02/19/getting-started-with-azure-devops-create-a-build-agent/" target="_blank" rel="noopener">Part 4: Getting started with Azure DevOps -create a build agent</a></span></span></span></span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><a href="http://skundunotes.com/2020/05/15/getting-started-with-azure-devops-create-a-build-pipeline-part-1-yaml-pipeline/" target="_blank" rel="noopener">Part 5: Getting started with Azure DevOps -create a build pipeline -Part 1 (YAML pipeline)</a></span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Part 6: Getting started with Azure DevOps -create a build pipeline -Part 2 (Classic Editor) (this note)</span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><a href="http://skundunotes.com/2019/12/27/azure-devops-deployment-groups/" target="_blank" rel="noopener">Part 7: Getting started with Azure DevOps -create a deployment group</a></span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><a href="http://skundunotes.com/2020/05/22/getting-started-with-azure-devops-create-a-release-definition/" target="_blank" rel="noopener">Part 8: Getting started with Azure DevOps -create a release definition</a></span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">In my <a href="http://skundunotes.com/2020/05/15/getting-started-with-azure-devops-create-a-build-pipeline-part-1-yaml-pipeline">previous note,</a> I discussed the approach to create a pipeline using YAML and why that’s the way forward. Picking up from where I left, here I discussed the process to create a pipeline using the old fashion classic editor. Like I mentioned earlier, this is the approach I have used extensively at work and am familiar with and hence stated that YAML is the way forward. There are some good reasons (that I mention in my previous note) for projects to migrate out of the classic editor based approach.</span></span></span>
<!--more-->
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><strong>Step 1:</strong> Getting back to the pipeline tab under Azure DevOps project we see that here too (like in YAML pipeline), we start with selecting our repo.</span></span></span>
<img class="alignnone size-full wp-image-516" src="https://skundunotes.com/wp-content/uploads/2020/05/ad-gs-pipeline-image8.png" alt="AD-GS-Pipeline-Image8" width="734" height="451">
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><strong>Step 2:</strong> ...followed by a template.</span></span></span>
<img class="alignnone size-full wp-image-517" src="https://skundunotes.com/wp-content/uploads/2020/05/ad-gs-pipeline-image9.png" alt="AD-GS-Pipeline-Image9" width="583" height="511">
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">There are a considerable number of template available, however, I started with an empty job. That way I can build the pipeline and keep it as clean and light as required.</span></span></span>

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><strong>Step 3:</strong> The first thing that we define in a pipeline is the Agent pool. An Agent pool is a group of machine/s where we build/compile our product. In the case of Azure DevOps services we get to choose whether we prefer Azure Pipelines (hosted) or Private (our own). I listed the steps in a separate blog on how to create your build agent <a href="http://skundunotes.com/2020/02/19/getting-started-with-azure-devops-create-a-build-agent/">here</a>.</span></span></span>
<img class="alignnone size-full wp-image-518" src="https://skundunotes.com/wp-content/uploads/2020/05/ad-gs-pipeline-image10.png" alt="AD-GS-Pipeline-Image10" width="857" height="394">
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">What we choose here determines where our code gets compiled/built. If there are no dependencies on third-party software that need to be installed on an agent, proceeding with Azure Pipelines (hosted) makes sense because that's one less system to manage.</span></span></span>

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><strong>Step 4</strong>: After that, we selected the location of our code repository</span></span></span>
<img class="alignnone size-full wp-image-519" src="https://skundunotes.com/wp-content/uploads/2020/05/ad-gs-pipeline-image11.png" alt="AD-GS-Pipeline-Image11" width="535" height="591">
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Here, we also set whether we want the build folder to <em>clean</em> (preferred) its local folder each time a build is requested and whether to <em>label sources </em>(preferred) with each build.</span></span></span>

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><strong>Step 5:</strong> We then move to agent jobs. This is where we add the tasks that are required to get our code compiled and packaged. Click on the + next to Agent job to bring up the options available</span></span></span>
<img class="alignnone size-full wp-image-520" src="https://skundunotes.com/wp-content/uploads/2020/05/ad-gs-pipeline-image12.png" alt="AD-GS-Pipeline-Image12" width="875" height="656">
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">I added the tasks that were performed sequentially based on our product’s build and package logic. Here is an example of a set of build jobs for Azure web apps for ASP.NET</span></span></span>
<img class="alignnone size-full wp-image-521" src="https://skundunotes.com/wp-content/uploads/2020/05/ad-gs-pipeline-image13.png" alt="AD-GS-Pipeline-Image13" width="577" height="661">

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><strong>Step 6: </strong>We can also choose what trigger we set to kick start the pipeline. A few basic options to set here would be: (i) set the path filter, (ii) continuous integration, and (iii) batch changes checked so that we’re aware of whether our check-ins/commits are causing any build failure.
</span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">We can also set the build-pipeline to be triggered on a certain schedule or when another build completes.</span></span></span>
<img class="alignnone size-full wp-image-522" src="https://skundunotes.com/wp-content/uploads/2020/05/ad-gs-pipeline-image14.png" alt="AD-GS-Pipeline-Image14" width="792" height="369">
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Once all the build settings were finalized, I saved and ran the build-pipeline to review if all settings were correct and if the build passed. </span></span></span>

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">And, t</span></span></span><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">hose are the steps to create a build pipeline in the classic editor.</span></span></span>

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">The difference from the YAML approach is that when we save this build-pipeline it does not get stored (commit/check-in) into the same repo. And that is where its limitation arises. Keeping code and the build-pipeline in the same repo is beneficial (as I discussed in Part 1 of this 2 part article). The other difference from a YAML approach is support for task groups -classic editor supports task groups while YAML does not. In the classic editor world, task groups reduce a lot of overhead when multiple build definitions need to consume an identical change.</span></span></span>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">That brings us to the question</span></span></span><strong><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"> -why would we (continue to) use the classic editor?</span></span></span></strong>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;"><strong>Answer:</strong> I think users will continue with the classic editor for projects and build-pipelines that <strong><em>use task groups and have existed before the YAML based approach was released</em></strong>.&nbsp;</span></span></span>
<strong><span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Conclusion:</span></span></span></strong>
<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">For new projects that are being started in Azure Repos using the GIT framework, I think the right choice is YAML pipelines. The learning curve might be steep, but it is worth spending time familiarizing with because of the long-term productivity and traceability benefit that we derive.</span></span></span>

<span style="font-size:18px;"><span style="font-family:calibri;"><span style="color:#000000;">Next, <a href="http://skundunotes.com/2019/12/27/azure-devops-deployment-groups/">Part 7: Getting started with Azure DevOps -create a deployment group</a></span></span></span>
